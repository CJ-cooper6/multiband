# 前端需要实现以下功能：

1. 实时显示多路视频流：前端需要有多个视频播放框，可以同时显示多路视频流。
2. 视频流的控制：前端需要提供视频流的控制，比如暂停、播放、快进、快退等操作。
3. 视频流的选择：前端需要提供选择多路视频流的功能，用户可以选择需要观看的视频流。
4. 视频流的导出：前端需要提供将视频流导出为文件的功能，用户可以将视频流保存到本地进行查看和分享。
5. 监控报警：前端需要提供监控报警功能，当监控发生异常时，需要通过前端实时展示报警信息，以便用户及时采取措施。





#### 后端的主要功能包括：

1. 视频数据的接收和处理：从各个摄像头接收视频流数据，对视频数据进行解码、处理和编码，存储到数据库或者本地文件系统中。
2. 数据库管理：管理摄像头的配置信息和视频数据的存储路径等。
3. 用户权限管理：对系统的各种功能进行权限控制，只允许授权用户进行访问和操作。
4. 系统状态监测和告警：监测系统的各项指标，如存储空间、网络带宽、摄像头状态等，当指标超过设定的阈值时，发送告警通知。
5. RESTful API 接口：提供与前端交互的接口，包括获取视频流、查询摄像头列表、查看历史录像等功能。
6. 后台任务管理：对后台任务进行管理，包括定时备份、数据清理、数据分析等任务的调度和执行。
7. 日志记录和分析：记录系统的各种操作、错误和告警信息，便于后续的分析和排查问题。

以上是后端需要实现的主要功能，具体实现方式和细节还需要根据实际需求进行设计和调整。





### windows下启动[nginx](https://so.csdn.net/so/search?q=nginx&spm=1001.2101.3001.7020)报错:

nginx: [emerg] CreateFile() “D:\桌面\nginx-1.12.0/conf/nginx.conf” failed (3: The system cannot find the path specified)



路径中的\n 被转义了



## 启动nginx

```
cd /h/nginx
./anginx -c conf/winnginx.conf
```



### 推流地址

```
"rtmp://127.0.0.1/live/stream"
```





# 推流拉流限制

https://juejin.cn/post/6844904106696376333



## nginx配置文件

如果您需要同时录制2个RTSP流，您可以在 Nginx 配置文件中添加多个 application 来实现。

例如，下面是一个支持同时录制2个RTSP流的 Nginx 配置文件：

```
worker_processes  1;

error_log logs/error.log error;

events {
    worker_connections  1024;
}

rtmp {
    server {
        listen 1935;

        application live1 {
            live on;
	record all;
    		record_unique on;  #指定如果文件已存在则不进行覆盖，直接创建新的文件
    		record_path "temp/live1";   
    		record_suffix -%Y-%m-%d-%H_%M_%S.flv;	#格式化输出
		record_max_size 5M;	   # 限制每个录制文件的最大大小
        }

application live2 {
            live on;
	record all;
    		record_unique on;  #指定如果文件已存在则不进行覆盖，直接创建新的文件
    		record_path "temp/live2";   
    		record_suffix -%Y-%m-%d-%H_%M_%S.flv;	#格式化输出
		record_max_size 5M;	   # 限制每个录制文件的最大大小
        }
		
        application hls {
            live on;
            hls on;  
            hls_path temp/hls;  
            hls_fragment 8s;  
        }
    }
}

http {
    server {
        listen       8080;
 
        location / {
            root html;
        }
 
        location /live {
            flv_live on; #打开HTTP播放FLV直播流功能
            chunked_transfer_encoding on; #支持'Transfer-Encoding: chunked'方式回复
 
            add_header 'Access-Control-Allow-Origin' '*'; #添加额外的HTTP头
            add_header 'Access-Control-Allow-Credentials' 'true'; #添加额外的HTTP头
        }
 
        location /hls {  
            #server hls fragments  
            types{  
                application/vnd.apple.mpegurl m3u8;  
                video/mp2t ts;  
            }  
            alias temp/hls;  
            expires -1;  
        }  
 
        location /stat {
            #推流播放和录制统计数据的配置
 
            rtmp_stat all;
            rtmp_stat_stylesheet stat.xsl;
        }
 
       location /stat.xsl {
            root html;
        }
 
    }
}

```

在上述配置文件中，我们定义了两个 RTMP 应用程序：`rtmp1` 和 `rtmp2`。它们都启用了录制功能，并将录制的视频保存到不同的路径中。如果您有多个 RTSP 流，您可以增加更多的 RTMP 应用程序来支持录制。



## 将文件当做直播送至live

```
ffmpeg -re -i sample.mp4 -c copy -f flv rtmp://127.0.0.1/live2/stream
```



## 获取设备命令

```
ffmpeg -list_devices true -f dshow -i dummy
```



## 摄像头推流

```
ffmpeg -f dshow -i video="Chicony USB2.0 Camera" -vcodec libx264 -preset:v ultrafast -tune:v zerolatency -f flv rtmp://127.0.0.1/live2/stream
```



## 麦克风推流

```
ffmpeg -f dshow -i audio="麦克风 (Realtek High Definition Audio)" -vcodec libx264 -preset:v ultrafast -tune:v zerolatency -f flv rtmp://127.0.0.1/live2/stream
```



## 一起推流

```
ffmpeg -f dshow -i video="Chicony USB2.0 Camera" -f dshow -i audio="麦克风 (Realtek High Definition Audio)" -vcodec libx264 -preset ultrafast -tune:v zerolatency -f flv rtmp://127.0.0.1/live2/stream
```



```
ffmpeg -f dshow -i video="Chicony USB2.0 Camera" -f dshow -i audio="麦克风 (Realtek High Definition Audio)" -vf unsharp -vcodec libx264 -preset ultrafast -tune:v zerolatency -f flv rtmp://127.0.0.1/live2/stream -vcodec libx264 -preset ultrafast -tune:v zerolatency -f flv rtmp://127.0.0.1/live1/stream
```

> 对 live2 进行锐化处理 ：-vf unsharp





## 前端

[前端播放rtmp协议的视频流文件_仗剑天涯，从摘要开始的博客-CSDN博客](https://blog.csdn.net/my_new_way/article/details/107883500)

[前端播放流媒体(RTMP,RTSP,HLS)_dj0379的博客-CSDN博客](https://blog.csdn.net/dj0379/article/details/73698624?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-8-73698624-blog-107883500.235^v32^pc_relevant_default_base3&spm=1001.2101.3001.4242.5&utm_relevant_index=11)





# flv.js

```
http://127.0.0.1:8080/live?port=1935&app=live2&stream=stream
```



[(142条消息) Nginx-http-flv-module流媒体服务器搭建+模拟推流+flv.js在前端html和Vue中播放HTTP-FLV视频流_霸道流氓气质的博客-CSDN博客](https://blog.csdn.net/BADAO_LIUMANG_QIZHI/article/details/129427853?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-3-129427853-blog-124705486.235^v32^pc_relevant_default_base3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-3-129427853-blog-124705486.235^v32^pc_relevant_default_base3&utm_relevant_index=6)



# 跨域解决

[(142条消息) [IOController\] ＞ Loader error, code = -1, msg = Failed to fetch_loader error,code_佳佳鸽的博客-CSDN博客](https://blog.csdn.net/weixin_43793181/article/details/122448821)





# go ffplay实时显示视频

```go
package main

import (
	"fmt"
	"os/exec"
	"sync"
)

var wg sync.WaitGroup

func main() {
	//Ffplay2()
	//
	wg.Add(2)
	go Ffplay()
	go Ffplay2()
	wg.Wait()
}

func Ffplay() {
	// 打开RTMP视频流，并使用ffplay实时显示视频
	cmd := exec.Command("ffplay", "-i", "rtmp://127.0.0.1/live1/stream")
	err := cmd.Start()
	fmt.Println(cmd.String())
	if err != nil {
		fmt.Println("err:", err.Error())
	}
	cmd.Wait()
	wg.Done()
}

func Ffplay2() {
	// 打开RTMP视频流，并使用ffplay实时显示视频
	cmd := exec.Command("ffplay", "-i", "rtmp://127.0.0.1/live2/stream") //, "-vf", "scale=640:-1
	err := cmd.Start()
	fmt.Println(cmd.String())
	if err != nil {
		fmt.Println("err:", err.Error())
	}
	cmd.Wait()
	wg.Done()
}
```





# 写论文准备

[【音视频处理】基础框架介绍，FFmpeg、GStreamer、OpenCV、OpenGL_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1uM411u7KK/?spm_id_from=333.337.search-card.all.click&vd_source=4a946f73257cf682d7fe977515421f3d)



# 锐化

[(148条消息) 《ffmpeg basics》中文版 -- 8.模糊、锐化和去噪_ffmpeg 颗粒效果_H&A的博客-CSDN博客](https://blog.csdn.net/qq_34305316/article/details/103935713)





## shell

[如何用 Shell 监控文件变化？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/325866964)



# 监控文件到数据库

```go
package main

import (
   "flag"
   "fmt"
   "os"
   "path/filepath"
   "strings"
)

func getFilelist(path string, stuffix string) (files []string) {
   err := filepath.Walk(path, func(path string, f os.FileInfo, err error) error {
      if f == nil {
         return err
      }
      if f.IsDir() {
         return nil
      }
      if strings.HasSuffix(path, stuffix) {
         files = append(files, path)
      }
      return nil
   })
   if err != nil {
      fmt.Printf("filepath.Walk() returned %v\n", err)
   }
   return
}
func main() {
   flag.Parse()
   root := flag.Arg(0) // 设置默认遍历当前目录
   if root == "" {
      root = "./"
   }
   fmt.Println(getFilelist(root, ".html"))
}
```

https://baijiahao.baidu.com/s?id=1645699703267037650&wfr=spider&for=pc





# todo

##### 后端

- [x] ==生成视频图片，保存到mysql==
- [x] ==返回视频信息接口==
- [ ] 用协程并发对不同源视频进行处理，记录不同数据源到数据库
- [ ] 下载视频接口
- [ ] 删除视频接口
- [ ] 对视频进行处理
- [ ] 可根据文件哈希值判断，不用重复生成。后续可支持redis
- [ ] 登录注册接口



##### 前端

- [ ] ==设计视频显示格式 jump.html页面==

- [ ] 去除侧边栏的js样式，因为要联网会有加载缓慢的问题

- [ ] 点击播放，播放视频

- [ ] 左边可以多添加一些标签

- [ ] 美化页面

  